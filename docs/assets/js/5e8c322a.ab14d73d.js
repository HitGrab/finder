"use strict";(self.webpackChunkfinder_docs=self.webpackChunkfinder_docs||[]).push([[594],{4099:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"api/index","title":"API","description":"Finder offers an imperative API that can access local state and mutate rules.","source":"@site/docs/api/index.md","sourceDirName":"api","slug":"/api/","permalink":"/finder/api/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"API","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"FinderRuleset","permalink":"/finder/rules/ruleset"},"next":{"title":"Search","permalink":"/finder/api/search-api"}}');var r=t(4848),a=t(8453);const o={title:"API",sidebar_position:3},s=void 0,l={},u=[];function d(e){const n={code:"code",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Finder offers an imperative API that can access local state and mutate rules."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"FinderCore<FItem, FContext> {\n    items: FItem[]\n\n    isReady: boolean;\n\n    isEmpty: boolean;\n\n    isLoading: boolean;\n\n    disabled: boolean;\n\n    state: 'loading' | 'empty' | 'groups' | 'items' | 'noMatches';\n\n    // in milliseconds\n    updatedAt: number;\n\n    context: FContext;\n\n    getRule(identifier: string | FinderRule): FinderRule;\n\n    setContext(context: FContext): void;\n\n    setIsLoading(value: boolean): void;\n\n    setItems(items: FItem[]): void;\n\n    setRules(rules: FinderRule[]): void;\n\n    // Test a ruleset without committing the state change.\n    test(mixins: SerializedMixins, isAdditive: boolean): FItem[]\n\n    events: {\n         // bind an event\n        on: (event: FinderEventName, callback: (payload: any) => void),\n\n        // unbind an event\n        off: (event: FinderEventName, callback: (payload: any) => void),\n\n        // trigger the passed callback while suppressing the event emitter.\n        silently: (callback: (payload: any) => void): void;\n\n        isSilent: () => boolean,\n    }\n\n    search: {\n        // String that is currently being searched for. Defaults to an empty string.\n        searchTerm: string\n\n        hasSearchTerm: boolean\n\n        hasSearchRule: boolean\n\n        setSearchTerm(value:string): void\n\n        // Reset searchTerm to an empty string.\n        reset(): void\n    };\n\n    filters: {\n        // Processed filter values keyed by filter rule id.\n        // If the rule has a defaultValue and no local state, the default will be returned.\n        // If a rule is required, the first valid option will be returned if possible.\n        values: {[filter.id]: any}\n\n        // Raw Filter values keyed by filter rule id.\n        // This is the raw state without any processing.\n        raw: {[filter.id]: any}\n\n        // Flat array of active rules.\n        // A filter rule is considered active if the rule has `required:true`, or has any defined value.\n        activeRules: FilterRule[]\n\n        // All rules, active or not. Useful for building control interfaces.\n        rules: FilterRule[]\n\n        // A filter rule is considered active if the rule has `required:true`, or has any defined value.\n        isActive(identifier: string | FilterRule) : boolean\n\n        // The processed value for a filter rule.\n        // If the rule has a defaultValue and no local state, the default will be returned.\n        // If a rule is required, the first valid option will be returned if possible.\n        get(identifier: string | FilterRule): any\n\n        // Check the processed value for a filter rule or option.\n        // For a boolean rule, if required or set, it will return true.\n        // For rules with multiple options, you can pass an option to see if that value is selected.\n        has(identifier: string | FilterRule, optionValue?: FilterOption | any): boolean\n\n        // Toggle a boolean filter or an option for a multiple filter.\n        toggle(identifier: string | FilterRule, optionValue?: FilterOption | any): void\n\n        // Set a filter value.\n        set(identifier: string | FilterRule, value: any): void\n\n        // Delete the internal state for this rule.\n        delete(identifier: string | FilterRule, value: any)\n\n        // Test an array of filter rules against the items array. Useful for building input controls.\n        test(options: { rules?: FilterRule[]; values?: any; context: FContext; isAdditive?: boolean;})\n\n        // Test a filter rule against the items array. Useful for building input controls.\n        testRule(options: { rule?: FilterRule; value?: any; context: FContext; isAdditive?: boolean;})\n\n        // Test every option in a filter against the items array. Useful for building input controls.\n        testRuleOptions(options: { rules: FilterRule; value?: any; context: FContext; isAdditive?: boolean;})\n    }\n\n    sortBy: {\n        // If no sort rule has been set, the first rule in the stack will be considered active.\n        activeRule?: SortByRule\n\n        // asc or desc\n        sortDirection: SortDirection,\n\n        // determine if the user has changed the value away from the default rule sort.\n        userHasSetSortDirection: boolean,\n\n        // All sorting rules. Useful for building controls.\n        rules: SortByRule[];\n\n        // set the active rule.\n        set(identifier?: string | SortByRule, direction?: SortDirection): void\n\n        setSortDirection(direction?: SortDirection): void\n\n        // rotate between the rule default, desc, and asc.\n        cycleSortDirection(): void\n\n        // flip between desc and asc.\n        toggleSortDirection(): void,\n\n        reset(): void,\n    }\n\n    groupBy: {\n\n        activeRule?: GroupByRule\n\n        requireGroup: boolean\n\n        // all defined GroupBy rules. Useful for controls.\n        rules: GroupByRule[]\n\n        groupIdSortDirection: 'asc' | 'desc'\n\n        set(identifier?: string | GroupByRule): void\n\n        toggle(identifier?: string | GroupByRule): void\n\n        // Determine how groups should be sorted.\n        setGroupIdSortDirection(direction?: 'asc' | 'desc')\n\n        reset()\n    }\n\n    matches: {\n        // Flat array of items that passed the search rule, all filters, have been sorted by any sortBy rules, and paginated.\n        // Will be undefined if requireGroup is set.\n        items?: FItem[];\n\n        // Flat array of groups that passed the search rule, all filters, have been sorted by any sortBy rules, and paginated.\n        // Will be undefined if requireGroup is NOT set.\n        groups?: FinderResultGroup<FItem>[];\n\n        numMatchedItems: number;\n\n        numTotalItems: number;\n\n        hasGroupByRule: boolean;\n    }\n\n    pagination: {\n\n        page: number\n\n        offset: number\n\n        numItemsPerPage?: number\n\n        numTotalItems: number\n\n        lastPage: number;\n\n        isPaginated: boolean\n    }\n\n}\n\n"})})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var i=t(6540);const r={},a=i.createContext(r);function o(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);